TUTORIAL TO USE

The following describes the topology and test cases that can be made after running LAUNCH.cmd

In order to appropriately test all the cases, we have included a topology file that represents bi-directional physical links between primary,backup servers, and GUI clients.

We also launch an ATM (GUI) with each branch above.
ATM 00050 [ NodeId: 150 ] goes with branch 00 [Primary 100, Backups: 101, 102]
ATM 00051 [ NodeId: 151 ] goes with branch 01 [Primary 101, Backups: 102, 100]
ATM 00052 [ NodeId: 152 ] goes with branch 02 [Primary 102, Backups: 100, 101]

Inputs to the GUI:
	- Serial Number: An integer representing the unique serial number
	- Source Account Number: A number of the format bb.aaaaa, such as 00.12345, to mean branch 00 account 12345. This is the target account for deposits, withdraws, and queries, and is the source account in a transfer
	- Dest Account Number: Same as source account number, but only used as the destination in a transfer
	- Amount: The amount to use in the transaction. Ignored in a check balance query transaction.

The following interactions through the gui will thouroughly the cases covered in the topology above:

GENERAL TESTS (from any account):
   - Test any action on a branch with the wrong account. 
		For example, using ATM 51, deposit to account 00.12345. This will fail since 51 is not connected to branch 00.
		Serial Number: 0
		Src account: 01.00051
		Dest account: 00.12345
		Amount:10.0
   - Test serial number field with a text input instead of a numeric input. Result is a rejection. 
		Serial Number: CS5414
		Src account: 01.00051
		Dest account: 
		Amount:
   - Test the src account field with a text input instead of a numeric input. Result is a rejection
		Serial Number: 0
		Src account: CS5414
		Dest account: 
		Amount:
   - Test the src account field with an input that does not follow the bb.aaaaa format. Result is rejection
		Serial Number: 0
		Src account: 11.11
		Dest account: 
		Amount:
   - Test the dest account field with a text input instead of numeric input. Result is a rejection
		Serial Number: 0
		Src account: aa.12345
		Dest account: 
		Amount:
   - Test the dest account field with an input that does not follow the bb.aaaaa format. Result is rejection
		Serial Number: 0
		Src account: 00.00010
		Dest account: 11.11
		Amount:11
   - Test the amount field with a negative number. Result is rejection
		Serial Number: 0
		Src account: 00.00050
		Dest account: 
		Amount: -500
   - Test the amount field with a non-numeric entry. Result is a rejection.
		Serial Number: 0
		Src account: 00.00050
		Dest account: 
		Amount: CS5414
	
TRANSFER TEST:
 (1) Testing transfer between two branches that can communicate with each other.
    - Since we know that there exist a bi-directional connection both ways between branch 00 and branch 01, that means 00.00050 and 01.00051 can make transfers between each other. So
	- Either on branch 00 or branch 01, using a different serial number, make a transfer of some amount from src account being either 00.00050 or 01.00051 to the destination account 01.00051 or 00.00050. On success of the transaction, go to the other branch to make sure it received the transfer by checking the balance on that account.
		Serial Number: 4
		Src account: 00.00050
		Dest account: 01.00051
		Amount: 10
(2) Testing a transfer when there is no link.
	If 00 tries to transfer to 02, the transfer should fail as no link exists between 00 and 02. 
	- Make a transfer from 00 to 02. An error will come up.
		Serial Number: 0
		Src account: 00.00050
		Dest account: 02.00052
		Amount: 10

		
PHASE3
-------------
Use LAUNCH.cmd to launch 3 GUIs  and 3 servers.
As specified in the "apps.txt" file, the following is the configuration:
GUIS: 50 (server 150) ,51 (server 151) ,52 (server 152)
SERVERS: 100,101,102
For Branch 50, the primary is 100, and backs are 101,102
For Branch 51, the primary is 101, and backups are 102,100
For Branch 52, the primary is 102, and backups are 100, 101

Scenarios to test:
(1) Failing a Primary:
	(1) Deposit or Withdraw on branch  50. This will contact server 100, and after processing the transaction, the primary 100 will synch with 101 and 102. Same goes with all other servers.
	(2) Using the oracle gui, fail node 100. Before notifying, make a deposit or a withdraw at branch 50 again. You will see the client should be waiting for a response from the primary since it has not been notified of 100's failure.
	(3) Notify the failure of 100 through the oracle. At this point, the GUI client should return with the processed deposit or withdraw request because it will have routed to the backup 101 when it was notified of failure.
(2)Failing a 2nd Primary:
	(1) Deposit or withdraw from branch 51. This will contact server 101, and after processing the transaction, the primary 101 will synch with 102, but not with 100 since it has already failed fro scenario (1)
	(2) Use the oracle gui to fail node 101. Before notifying of the failure, attempt to make a deposit or withdraw at branch 51 again. You will see the client should be waiting for a response from the primary since it has not been notified of 101's failure.
	(3) Before notifying of the failure, attempt to make a deposit or withdraw at branch 50 again. Because the new primary for 50 was 101 from scenario (1), this should also keep waiting on the failed primary.
	(4) Notify of the failure, both 50 and 51 should complete their transactions and reroute them to their new primary 102.
	(5) 102 will be a primary for all 50,51, and 52
(3) Testing Recovery:
	(1) Use the oracle gui to recover 100. You can try to deposit or withdraw from branch 50 or 51, and they should still work because they will be contacting 102, and branch 102 will not synch with anything since it has not been notified of recovery of 100 yet. 
	(2) Use the oracle gui to notify recovery of 100. At this point, 100 will become a backup for both branches 50 and 51 and 52.
	(3) In order to see that 100 is the backup, we need to fail 102 to see if 50,51,52 will reroute their requests to 100 once notified of the failure of 102. 
	(4) Therefore, use the oracle gui to fail 102. You can attempt to deposit or withdraw from 50,51,52, but all of them should be waiting since they haven't been notified of the failure.
	(5) Using the oracle, notify failure of 102. Now 50,51,52 clients should return because their requests would have been rerouted to the new primary 100.
(4) Testing Transfers + Failures:
	(1) Use LAUNCH.cmd to launch the original 3 GUIS and 3 SERVERS.
	(2) Attempt to transfer between two branches. From 50 to 51, from 51 to 52, or any other combination. Then really quickly press the fail button.
	(2) However, the transfers may happen a bit too fast for a person to click fail right in the middle of a transfer, one way to slow down the transfer transaction is to put sleep statements between the request and response in the transfer function.
	(3) Once the node that you are transferring to fails and before the oracle notifies of the failure, the transfer will hang.
	(4) Once you notify the failure of the node being transferred to, the transaction should reroute to a backup of the node and the transfer will complete.