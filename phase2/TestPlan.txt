Test Plan

Basic description of snapshot algorithm:
The brains of the snapshot algorithm is all in processMessage located in the SnapshotHandler.java which stores a NodeState, a list of channels incoming we will be waiting on, and a list of messages which will be recorded during duration of the snapshot.

The list of channels that are incoming to each branch are referred to "unplugged channels". Once we start the snapshot mode for a branch or a node, we wait to receive the "snapshot messages" from all channels incoming to "plug" the channels we are waiting on, this will cause us to remove the channel from the list. After we receive a "plug" message, we also stop recording any transactions that occur from the source of the "plug" message. Once everything on the list is "plugged" or removed, the snapshot is finished. We then broadcast a "DisplaySnapshotMessage" to all our channels out. Since we only have one GUI, and since only GUIS can process these types of messages, the GUI will receive the request and display snapshot info.
If a branch receives a "snapshot message" for the first time and it is not in snapshot mode, then we enter snapshot mode, create a list of "unplugged channels" or channels in that we will be waiting on to "plug" and copy the local branch state into a new object. Then the process will continue as described in previous paragraph.

At each node, once a "snapshot message" is received then either we are not in snapshot mode OR we are in snapshot mode and the message is from a plugged channel In, then we re-enter snapshot mode. This means we wait for more "plugs"  or "snapshot messages" from our channel Ins, but if we are entering for first time we record our state (copy it). Then, regardless of previous step, we remove the channel In from the unplugged list thereby "plugging" it. If all channels are plugged, we exit snapshot mode. We then broadcast a
	 * "DisplaySnapshotMessage" to all of our channel outs. Since we only have
	 * one GUI, and since only GUIs can process these messages, the GUI will
	 * receive the request and display snapshot info.
A. Testing accurate states of bank accounts and balances
In order to test the non-zero accounts and balance of the snapshot that is displayed on the GUI, we performed the tutorial that was stipulated in phase 1 and checked at each step, that the expect amounts were displayed in the appropriate snapshots for each branch.
We did deposits, withdrawals, and transfers from branches who had different topologies whether uni-directional or bi-directional.

B. Testing accuracy of transitional messages recorded during snapshot algorithm

The more complicated aspect of testing the snapshot accuracy was testing the transactions in progress. This was complicated by the fact that the snapshot algorithm performed too quickly for us to use the GUI interface and user input to accomplish a simulation of a situation where a transaction like a transfer would be in progress while the snapshot was being taken by all branches. To test this, we had to simulate delays in the network message. In NetworkInterface file, we currently have commented out a thread.sleep, which is what was used to simulate delays in the network. Uncommenting this, we tested taking a snapshot and doing a transfer, or doing a transfer and then taking a snapshot, to see if we caught the deposit or withdraw relating to the transfer in progress. If we did catch any transactions in progress, we verified by looking at the point at which this transaction was recorded in the snapshot. We did this by logging appropriate information to the console. We then verified, to make sure that the transaction was recorded in snapshot mode rather than not, and make sure it was the appropriate amount. We also made sure the account balances that were related in that transfer transaction reflected this fact. For example, if an account didn't yet receive the deposit at the time the snapshot finished, we should see a transactional message and vice versa.

   We also decided, instead of using user input, we wrote code to call the functions we wanted. We created a testing topology file so we could simulate a transfer that we were sure would end up in progress when the snapshot had finished. We then verified it by running the code.

C.Finally, to test multiple concurrent snapshots we did the following:
   Our implementation also allows the user to handle concurrent snapshots and have snapshots "work with each other". If two snapshots are initiated one after the other or concurrently from different branches, what will happen is because of our set up, is that the initial snapshot will be extended and record extra messages. Therefore, the second snapshot initiated by a user will be an extension of the first snapshot initiated.
It is hard to test this through the GUI, we had to rely on the logging of our servers and guis to determine that multiple snapshots were sharing information.

It can be more easily seen, however, through the explanation of our code implemented in SnapshotHandler.java.
When a user first presses "take snapshot" (let us assume that the branch currently is not taking a snapshot for explanation's sake), the branch will enter snapshot state by copying the current branch state into a new object-- the snapshot branch state copy, creating a list of "unplugged" channels in, and modifying the state to indicate that the branch is currently in snapshot mode. It will then "plug" the channel from the GUI since it received the "take snapshot" message from the Gui by removing the GUI channel from the "unplugged" channels in list, and will then broadcast a snapshot message to all its outgoing channels, WhoNeighbors from phase 1. Meanwhile, however, the user presses "take snapshot" again before the first "take snapshot" finishes. Then what happens is that when the second snapshot message reaches the snapshot handler, we know that the GUI id will not be in the unplugged channels in list since it was plugged previously by the first snapshot message, and the branch will then re-enter into snapshot mode. By re-entering, the branch snapshot handler will add all the outgoing channels again to the "unplugged" list potentially creating duplicate values in the list, and broadcast a snapshot message again, thereby extending the time of the snapshot. It will NOT, however, copy the node state. Therefore, the second snapshot will be an extension of the first.


