TestPlan: Vera Kutsenko, Jeremy Fein

In order to test our primary back up with did the following:

For all scenarios when we failed a given server, we would fail the server first, then attempt to use the client to make some transaction, to ensure that it will be waiting on the primary since we have not notified of the failed primary. We then notify of the failure, using this we ensured the client then switched to the next available backup and completed the transaction. After this, we would recover at which point no one knows of the recovery yet. Once we notify of the recovery, we made sure that the node is synched with the appropriate data and up as a back up server.

(1) Tested with one client with one primary and backup server. Crashed the node with the primary server and notified those who were subscribed to the node of the failure to ensure that the backup would take over, and then recovered, notified of recovery to make sure the old primary would now be a back up.

Client: Primary Backup
A:	100	101

 Do a transaction into A. Crash 100. Attempt to do another transaction into A, but since 100 failed but we don't know about it yet, A is stuck waiting. Notify failure, A should route its transaction to 101 which becomes new primary. Recover 100, notify of recovery, which will make 100 the new backup. 	 

(2) Tested with two clients and one primary, two backup servers each where the primary of one client serves as a backup of the other, and vice versa. The two clients have two different primaries. We proceeded to do some deposit transactions to make sure we had some data for an account for each client. We then proceeded to fail both primaries for both clients which would mean that the both clients, once notified, will contact the same server who will now be a primary for both clients. We then notified, and checked to make sure the primary was correct.

Scenario described above is demonstrated below:
Client: Primary Backup Backup
A: 	101, 	100, 	102
B: 	100, 	101, 	102

We made deposits into A, B. We then failed 101, 100. Before notifying of the failure, we attempted to do deposit,withdraw, or query transaction to make sure the client will start waiting for a response from the primary that's failed. We then notify of the failure, and then both clients will reroute their transactions to 102, and 102 will serve as the primary for both.

   We then proceeded to recover 101 and 100 to ensure that they became new backups for A and B.

(3) For scenarios (1) & (2) we tested failure of backups only, to make sure that once we notified of recovery for backups, they came back as backups and synched with the other servers.

We did this with withdraw, transfer, and deposit requests.

(4) To test transfer requests we:
	For transfer requests, because of their fast nature, we put sleep statements in different parts of the transfer function in BranchState in order to allow us time to fail a remote node in order to properly test transfer.
	a. Tested failure before making the request to deposit, but after withdrawing.
		This is fine because no state would have been recorded. A can retry the transaction to a new primary that it will choose from the backups.
	b. Tested failure after making the request to deposit to a remove branch, but before receiving a response from the other branch we are trying to transfer to.
		This will be hang if the system has not been notified of the failure. Once the system is notified, the transaction should complete as the request will be rerouted to a backup.	

(5) Tested synch requests:

  Client: Primary Backup Backup
  A:	  100	   101 	 102

	a. Synch Requests: We had a client,A, with one primary,100, and two backups, 101 and 102.
		i. When A made a transaction, we considered the scenario if 100 failed after 101 received a synch request with the updated bank state, but before 102 received a synch request.
			- In this case, when A is notified of failure it will send the same request to 101 which will already have the updated state and that transaction, so it will just ignore the transaction, and will then synch with its backup 102, and 100 if we decide to recover 100 so that both 102 and 100 will have the updated states.
			- If A is notified of failure and it sends its request to 102 instead which doesn't have the current updated state, then that is okay, 102 will register that state, and will synch with 101 and 100 if 100 is back up, so that 100 will have an updated state. 
		ii. If 100 failed before synching.
			Then A will retry the transaction to either 101 or 102, and everything will be fine.
		iii. If 100 failed after synching to both.
			Then A will retry the transaction to 101 or 102, but since both already saw the transaction, they will ignore it, and the state will stay the same.
