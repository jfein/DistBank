INSTALLATION TUTORIAL:

	To install and run on Windows from the .zip folder, first unzip the folder to the desired directory. Open a Windows shell to this directory, and set the Java path as follows (change to your local Java installation path):
		
		set PATH=C:\Program Files\Java\jdk1.7.0_18\bin;%PATH%
		
	Now, you can compile the BranchGui and BranchServer with the following two commands:
		javac .\src\core\node\NodeRunner.java -sourcepath .\src -d .\bin
		javac .\src\bank\branch\BranchApp.java -sourcepath .\src -d .\bin
		javac .\src\bank\gui\BranchGuiApp.java -sourcepath .\src -d .\bin
	
	In this phase, we have created a generic NodeRunner class that launches any app as specified in the apps.txt folder. An app will specify a NodeId that is associated with it. If an app is a BranchServer app, it will specify a primary server(NodeId) first and then any backup server NodeIds. This is an example:
AppIds    AppName  		    NodeIDs
AA1	     bank.gui.BranchGuiApp   XXX
AA2           bank.branch.BranchApp  XXP XXB XXB2
AA3          orace.OracleApp 	     XXO
Therefore, to launch any app you must run the following command. The XXX is the 3 digit id that is used to identify each app. This 3 digit id can be found under the NodeIDs column in in apps.txt. 
	
		start java -cp "./bin" "core/node/NodeRunner" XXX

Therefore, to launch in the example above we would need to use the above command and use XXX,XXP, XXB,XXB2,XXO as inputs to launch all of those branch, oracle, and branch gui apps.
		
	The script "LAUNCH.cmd" performs the necessary commands to start BranchGui's and BranchServer's that correspond to the default "topology_file.txt" and "server_node_mapping.txt" and "apps.txt". The "topology_file.txt" represents physical links that all the nodes have between each other. The script will start 3 GUIs and 3 servers. The GUIS have physical links to all the servers. Furthermore, "apps.txt" specifies that server 100 will serve as primary for branch 00, 101 for branch 01, and 102 for branch 02. In each scenario, the  other servers will serve as backups. This configuration can be started using the default files by running the LAUNCH.cmd script.	
	
-------------------------------------------------------------------------------

TUTORIAL

The following describes the topology and test cases that can be made after running LAUNCH.cmd

In order to appropriately test all the cases, we have included a topology file that contains three branches (branch 00, branch 01, and branch 02) connected in this manner:

00->01
01->00
01->02

We also launch an ATM (GUI) with each branch above.
ATM 00050 goes with branch 00
ATM 00051 goes with branch 01
ATM 00052 goes with branch 02

Therefore, branch 0 and 1 can communicate with each other. Branch 1 has a unidirectional link to branch 2, and branch 2 has no links with branch 0. This topology layout covers all the possible cases of how the branches can be connected to each other. Either there is a uni-directional link both ways between the branches, or there is only one uni-directional link from one branch to another, or there are no links between two branches at all.

Inputs to the GUI:
	- Serial Number: An integer representing the unique serial number
	- Source Account Number: A number of the format bb.aaaaa, such as 00.12345, to mean branch 00 account 12345. This is the target account for deposits, withdraws, and queries, and is the source account in a transfer
	- Dest Account Number: Same as source account number, but only used as the destination in a transfer
	- Amount: The amount to use in the transaction. Ignored in a check balance query transaction.

The following interactions through the gui will thouroughly the cases covered in the topology above:

GENERAL TESTS (from any account):
   - Test any action on a branch with the wrong account. 
		For example, using ATM 51, deposit to account 00.12345. This will fail since 51 is not connected to branch 00.
		Serial Number: 0
		Src account: 01.00051
		Dest account: 00.12345
		Amount:10.0
   - Test serial number field with a text input instead of a numeric input. Result is a rejection. 
		Serial Number: CS5414
		Src account: 01.00051
		Dest account: 
		Amount:
   - Test the src account field with a text input instead of a numeric input. Result is a rejection
		Serial Number: 0
		Src account: CS5414
		Dest account: 
		Amount:
   - Test the src account field with an input that does not follow the bb.aaaaa format. Result is rejection
		Serial Number: 0
		Src account: 11.11
		Dest account: 
		Amount:
   - Test the dest account field with a text input instead of numeric input. Result is a rejection
		Serial Number: 0
		Src account: aa.12345
		Dest account: 
		Amount:
   - Test the dest account field with an input that does not follow the bb.aaaaa format. Result is rejection
		Serial Number: 0
		Src account: 00.00010
		Dest account: 11.11
		Amount:11
   - Test the amount field with a negative number. Result is rejection
		Serial Number: 0
		Src account: 00.00050
		Dest account: 
		Amount: -500
   - Test the amount field with a non-numeric entry. Result is a rejection.
		Serial Number: 0
		Src account: 00.00050
		Dest account: 
		Amount: CS5414

STATE CONSISTENCY:
    - Deposit 10$ into account 00.00000 with serial number 0 on ATM 50.
		Serial Number: 0
		Src account: 00.00050
		Dest account: 
		Amount: 10

    - Click Take Snapshot button, you should see a panel on the left appear with the src account and the deposit amount of 10.0.

    - Try to perform another action (deposit,withdraw, check balance) with same serial number 0. This will be rejected.
		Serial Number: 0
		Src account: 00.00050
		Dest account: 
		Amount: 10

    - Withdraw 5$ from this account with serial number 1. 
		Serial Number: 1
		Src account: 00.00050
		Dest account: 
		Amount: 5

    - Click Take Snapshot button, you should see a panel on the left appear with src account and the balance of 5.0

    - Check balance of this account with serial number 2. Will return $5.
		Serial Number: 2
		Src account: 00.00050
		Dest account: 
		Amount: 
	
TRANSFER TEST:
 (1) Testing transfer between two branches that can communicate with each other.
    - Since we know that there exist a uni-directional connection both ways between branch 00 and branch 01, that means 00.00050 and 01.00051 can make transfers between each other. So
	- Either on branch 00 or branch 01, using a different serial number, make a transfer of some amount from src account being either 00.00050 or 01.00051 to the destination account 01.00051 or 00.00050. On success of the transaction, go to the other branch to make sure it received the transfer by checking the balance on that account.
		Serial Number: 4
		Src account: 00.00050
		Dest account: 01.00051
		Amount: 10
      - Click Take Snapshot button after the transfer button. Because the snapshot process is fast, you may not be able to catch the message transferring. When you click the take snapshot button, you will see on the top part of the left panel any messages that are currently in transaction, and the non-zero account balances for the local branches. Therefore, at account 00.00050 you should see less $10, and at account 01.00051 you should see increase in 10.
	- attempt doing a transfer with a previously used serial number. Will fail.
		Serial Number: 4
		Src account: 00.00050
		Dest account: 01.00051
		Amount: 10
   
(2) Testing transfer between a branch that has a uni-directional link to another branch.
	- In this example, we know 01 can communicate with 02, but 02 can not communicate with 01. Therefore, if we try to transfer from 01 to 02, it should withdraw from our account, and should deposit into the account at 02, but we will never get a response.
		Serial Number: 5
		Src account: 01.00050
		Dest account: 02.00052
		Amount: 10
(3) Testing a transfer when there is no link.
	If 00 tries to transfer to 02, the transfer should fail as no link exists between 00 and 02. 
	- Make a transfer from 00 to 02. An error will come up.
		Serial Number: 0
		Src account: 00.00050
		Dest account: 02.00052
		Amount: 10
PHASE 2 FURTHER TUTORIAL EXPLANATION
---------------------
You can use take snapshot as specified in the tutorial above from Phase 1.

This is a general description of general user input for testing which you can observe by playing around on your own of taking the snapshots as specified above from the tutorials from Phase 1.
(1) Testing bank account balances on taking snapshots.
	- On launch, deposit, withdraw, or transfer any amounts of your choice between the different branches. At any point in time, if you take a snapshot, the account balances on each branch for each account on that branch will be accurate to what user input you have provided.

(2) Testing transactions
It will be hard to test transactions only by use of user input into the GUI. Although you can try to do actions (Withdraw, Deposit, Transfer) really fast after taking the snapshots, due to the fast nature of algorithm, it will probably not catch any messages in transition. However, we have tested this aspect by emulating delays in message sending which is further described in our TestPlan. We,however, decided to remove the delays because we did not want to include them in the main product. 
HOWEVER:
 -- You can test transactions, by uncommenting the Thread.Sleep in the NetworkInterface class in the getMessage() method. If you uncomment this, you can start a snapshot, then say deposit,withdraw, or transfer, and possibly catch it in the transactions of one of the branches! As described in TestPlan.txt, we used this to help simulate delays in order to catch messages in progress to display after snapshot finished.

PHASE3
-------------
Use LAUNCH.cmd to launch 3 GUIs  and 3 servers.
As specified in the "apps.txt" file, the following is the configuration:
GUIS: 50 (server 150) ,51 (server 151) ,52 (server 152)
SERVERS: 100,101,102
For Branch 50, the primary is 100, and backs are 101,102
For Branch 51, the primary is 101, and backups are 102,100
For Branch 52, the primary is 102, and backups are 100, 101

Scenarios to test:
(1) Failing a Primary:
	(1) Deposit or Withdraw on branch  50. This will contact server 100, and after processing the transaction, the primary 100 will synch with 101 and 102. Same goes with all other servers.
	(2) Using the oracle gui, fail node 100. Before notifying, make a deposit or a withdraw at branch 50 again. You will see the client should be waiting for a response from the primary since it has not been notified of 100's failure.
	(3) Notify the failure of 100 through the oracle. At this point, the GUI client should return with the processed deposit or withdraw request because it will have routed to the backup 101 when it was notified of failure.
(2)Failing a 2nd Primary:
	(1) Deposit or withdraw from branch 51. This will contact server 101, and after processing the transaction, the primary 101 will synch with 102, but not with 100 since it has already failed fro scenario (1)
	(2) Use the oracle gui to fail node 101. Before notifying of the failure, attempt to make a deposit or withdraw at branch 51 again. You will see the client should be waiting for a response from the primary since it has not been notified of 101's failure.
	(3) Before notifying of the failure, attempt to make a deposit or withdraw at branch 50 again. Because the new primary for 50 was 101 from scenario (1), this should also keep waiting on the failed primary.
	(4) Notify of the failure, both 50 and 51 should complete their transactions and reroute them to their new primary 102.
	(5) 102 will be a primary for all 50,51, and 52
(3) Testing Recovery:
	(1) Use the oracle gui to recover 100. You can try to deposit or withdraw from branch 50 or 51, and they should still work because they will be contacting 102, and branch 102 will not synch with anything since it has not been notified of recovery of 100 yet. 
	(2) Use the oracle gui to notify recovery of 100. At this point, 100 will become a backup for both branches 50 and 51 and 52.
	(3) In order to see that 100 is the backup, we need to fail 102 to see if 50,51,52 will reroute their requests to 100 once notified of the failure of 102. 
	(4) Therefore, use the oracle gui to fail 102. You can attempt to deposit or withdraw from 50,51,52, but all of them should be waiting since they haven't been notified of the failure.
	(5) Using the oracle, notify failure of 102. Now 50,51,52 clients should return because their requests would have been rerouted to the new primary 100.
(4) Testing Transfers + Failures:
	(1) Use LAUNCH.cmd to launch the original 3 GUIS and 3 SERVERS.
	
Deposit
TEAM MEMBERS 
---------------------
PHASE 1: Vera Kutsenko & Jeremy Fein
PHASE 2: Vera Kutsenko & Jeremy Fein
